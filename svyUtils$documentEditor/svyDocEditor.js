/**
 * @type {String}
 *
 * @properties={typeid:35,uuid:"B682CF5E-6254-4515-A42C-9575EA97C206"}
 */
var printCSSStyle = ":root{--ck-color-mention-background:hsla(341, 100%, 30%, 0.1);--ck-color-mention-text:hsl(341, 100%, 30%);--ck-highlight-marker-blue:hsl(201, 97%, 72%);--ck-highlight-marker-green:hsl(120, 93%, 68%);--ck-highlight-marker-pink:hsl(345, 96%, 73%);--ck-highlight-marker-yellow:hsl(60, 97%, 73%);--ck-highlight-pen-green:hsl(112, 100%, 27%);--ck-highlight-pen-red:hsl(0, 85%, 49%);--ck-image-style-spacing:1.5em;--ck-todo-list-checkmark-size:16px}.ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}.ck-content pre{padding:1em;color:hsl(0,0%,20.8%);background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;text-align:left;direction:ltr;tab-size:4;white-space:pre-wrap;font-style:normal;min-width:200px}.ck-content pre code{background:unset;padding:0;border-radius:0}.ck-content hr{margin:15px 0;height:4px;background:#ddd;border:0}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{color:var(--ck-highlight-pen-red);background-color:transparent}.ck-content .pen-green{color:var(--ck-highlight-pen-green);background-color:transparent}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image,.ck-content .table{margin:1em auto;display:table}.ck-content .image>figcaption{display:table-caption;caption-side:bottom;word-break:break-word;color:#333;background-color:#f7f7f7;padding:.6em;font-size:.75em;outline-offset:-1px}.ck-content .image{clear:both;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:50px}.ck-content img{max-width:100%}.ck-content .image.image_resized{max-width:100%;display:block;box-sizing:border-box}.ck-content .image.image_resized img{width:100vw}.ck-content .image.image_resized>figcaption{display:block}.ck-content span[lang]{font-style:italic}.ck-content span {white-space: pre-wrap}.ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}.ck-content code{background-color:hsla(0,0%,78%,.3);padding:.15em;border-radius:2px}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b2b2b2}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border:1px solid #bfbfbf}.ck-content .table table th{font-weight:700;background:hsla(0,0%,0%,5%)}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-content .page-break{position:relative;clear:both;padding:5px 0;display:flex;align-items:center;justify-content:center}.ck-content .page-break::after{content:'';position:absolute;width:100%}.ck-content .page-break__label{position:relative;z-index:1;padding:.3em .6em;display:block;text-transform:uppercase;border:1px solid #c4c4c4;border-radius:2px;font-family:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;font-size:.75em;font-weight:700;color:#333;background:#fff;box-shadow:2px 2px 1px hsla(0,0%,0%,.15);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ck-content .media{clear:both;margin:1em 0;display:block;min-width:15em}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;display:inline-block;position:relative;width:var(--ck-todo-list-checkmark-size);height:var(--ck-todo-list-checkmark-size);vertical-align:middle;border:0;left:-25px;margin-right:-15px;right:0;margin-left:0}.ck-content .todo-list .todo-list__label>input::before{display:block;position:absolute;box-sizing:border-box;content:'';width:100%;height:100%;border:1px solid #333;border-radius:2px;transition:box-shadow 250ms ease-in-out,background 250ms ease-in-out,border 250ms ease-in-out}.ck-content .todo-list .todo-list__label>input::after{display:block;position:absolute;box-sizing:content-box;pointer-events:none;content:'';left:calc(var(--ck-todo-list-checkmark-size)/ 3);top:calc(var(--ck-todo-list-checkmark-size)/ 5.3);width:calc(var(--ck-todo-list-checkmark-size)/ 5.3);height:calc(var(--ck-todo-list-checkmark-size)/ 2.6);border-style:solid;border-color:transparent;border-width:0 calc(var(--ck-todo-list-checkmark-size)/ 8) calc(var(--ck-todo-list-checkmark-size)/ 8) 0;transform:rotate(45deg)}.ck-content .todo-list .todo-list__label>input[checked]::before{background:#25ab33;border-color:#25ab33}.ck-content .todo-list .todo-list__label>input[checked]::after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}.ck-content .raw-html-embed{margin:1em auto;min-width:15em;font-style:normal}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}";

/**
 * Orientation options for PDF export
 * @public
 * @enum
 * @see Exporter.setOrientation
 * @properties={typeid:35,uuid:"5FF39323-777B-4B3F-930D-F2B6BE25F9AD",variableType:-4}
 */
var ORIENTATION = {
	PORTRAIT: 'Portrait',
	LANDSCAPE: 'Landscape'
};

/**
 * Page size options for PDF export
 * @public
 * @enum
 * @see Exporter.setPageSize
 * @properties={typeid:35,uuid:"0CEC1095-8E27-4568-B972-EB0B26869C85",variableType:-4}
 */
var PAGE_SIZE = {
	A0: 'A0',
	A1: 'A1',
	A2: 'A2',
	A3: 'A3',
	A4: 'A4',
	A5: 'A5',
	A6: 'A6',
	A7: 'A7',
	A8: 'A8',
	A9: 'A9',
	A10: 'A10'
};

/**
 * @public
 * @enum {String}
 * @properties={typeid:35,uuid:"45646E48-A651-4EE5-9824-B33A2452062C",variableType:-4}
 */
var TAGS = {
	REPEAT: '$',
	TAG: '#',
	IF: '@'
};

/**
 * @private
 * @enum {String}
 * @properties={typeid:35,uuid:"45A567D0-9184-4613-A30B-CF3023CF79D4",variableType:-4}
 */
var DEFAULT_REPEATER = {
	START: 'startRepeater',
	STOP: 'endRepeater'
};

/**
 * @private
 * @enum {String}
 *
 * @properties={typeid:35,uuid:"955C6F99-838F-4A47-915A-042E3EFD9150",variableType:-4}
 */
var DEFAULT_IF = {
	IF_OPEN: 'if',
	IF_CLOSE: 'endIf'
};

/**
 * @private
 * @enum {RegExp}
 * @properties={typeid:35,uuid:"3CFFA067-6A8D-402E-B69D-4953037D26EC",variableType:-4}
 */
var REGEX = {
	MENTION: /<span[^>]+\ssvy-mention\b[^>]*>.*?<\/span>(&nbsp;)?/gm,
	ALL_START_REPEAT: /<span[^>]+\ssvy-mention\b[^>]*>\$startRepeater\b[^<]*<\/span>(\s|&nbsp;|<br>)*/gm,
	START_REPEAT: /^<span[^>]+\ssvy-mention\b[^>]*>\$startRepeater\b[^<]*<\/span>(\s|&nbsp;|<br>)*/gm,
	START_REPEAT_TABLE: /^<span[^>]+\ssvy-mention\b[^>]*>\$startRepeater\b[^<]*<\/span>(&nbsp;|<\/p>)*?(<figure class="table".*?>)?<table.*?>/gm,
	END_REPEAT$: /<span[^>]+\ssvy-mention\b[^>]*>\$endRepeater<\/span>(&nbsp;)?$/gm,
	END_REPEAT: /<span[^>]+\ssvy-mention\b[^>]*>\$endRepeater<\/span>(&nbsp;)?/gm,
	END_REPEAT_TABLE: /<\/table>(<\/figure>)?(<p>)?<span[^>]+\ssvy-mention\b[^>]*>\$endRepeater<\/span>(&nbsp;|<\/p>|<br>)*$/gm,
	FULL_REPEAT_BLOCK: /(<span[^>]+\ssvy-mention\b[^>]*>\$startRepeater\b[^<]*<\/span>(&nbsp;)?(<\/p>)?(<figure class="table".*?>)?(<table.*?>)?).*((<\/table>)?(<\/figure>)?(<p>)?<span[^>]+\ssvy-mention\b[^>]*>\$endRepeater<\/span>(&nbsp;)?)/gm,
	FULL_REPEAT_BLOCK_FIRST_MATCH: /(<span[^>]+\ssvy-mention\b[^>]*>\$startRepeater\b[^<]*<\/span>(&nbsp;)?(<\/p>)?(<figure class="table".*?>)?(<table.*?>)?).*?((<\/table>)?(<\/figure>)?(<p>)?<span[^>]+\ssvy-mention\b[^>]*>\$endRepeater<\/span>(&nbsp;)?)/gm,
	FULL_IF_BLOCK: /(<span[^>]+\ssvy-mention\b[^>]*>\@if\b[^<]*<\/span>(&nbsp;)?(<\/p>)?(<figure class="table".*?>)?(<table.*?>)?).*((<\/table>)?(<\/figure>)?(<p>)?<span[^>]+\ssvy-mention\b[^>]*>\@endIf<\/span>(&nbsp;)?)/gm,
	START_IF: /^<span[^>]+\ssvy-mention\b[^>]*>\@if\b[^<]*<\/span>(\s|&nbsp;|<br>)*/gm,
	CLOSE_IF: /<span[^>]+\ssvy-mention\b[^>]*>\@endIf<\/span>(&nbsp;)?$/gm,
	ALL_START_IF: /<span[^>]+\ssvy-mention\b[^>]*>\@if\b[^<]*<\/span>(\s|&nbsp;|<br>)*/gm,
	NAMED_CLOSE_IF: /<span[^>]+\ssvy-mention\b[^>]*>\@endIf\.\b[^<]*<\/span>(&nbsp;)/gm,
	FULL_TABLE_ROW: /<tr>.*<\/tr>/gm,
	FULL_TABLE_HEADER: /<tr>.*<\/thead><tbody>/gm,
	BR_END: /<br>$/gm
};


/**
 * @private
 * @enum {String}
 * @properties={typeid:35,uuid:"A910F6B0-4107-4251-9D11-55A07C41514C",variableType:-4}
 */
var REGEX_STRING = {
	FULL_IF_BLOCK: '(<span[^>]+\\ssvy-mention\\b[^>]*>\\@if\\.{{0}}\\b[^<]*<\\/span>(&nbsp;)?(<\\/p>)?(<figure class="table".*?>)?(<table.*?>)?).*?((<\\/table>)?(<\\/figure>)?(<p>)?<span[^>]+\\ssvy-mention\\b[^>]*>\\@endIf\.{{0}}<\\/span>(&nbsp;)?)',
	START_IF: '<span[^>]+\\ssvy-mention\\b[^>]*>\\@if\\.{{0}}\\b[^<]*<\\/span>(\\s|&nbsp;|<br>)*',
	CLOSE_IF: '<span[^>]+\\ssvy-mention\\b[^>]*>\\@endIf\.{{0}}<\\/span>(&nbsp;)*',
	FULL_REPEAT_BLOCK: '(<span[^>]+\\ssvy-mention\\b[^>]*>\\$startRepeater.{{0}}<\\/span>(&nbsp;)?(<\\/p>)?(<figure class="table".*?>)?(<table.*?>)?).*?((<\\/table>)?(<\\/figure>)?(<p>)?<span[^>]+\\ssvy-mention\\b[^>]*>\\$endRepeater.{{0}}<\\/span>(&nbsp;)?)',
	START_REPEAT: '^<span[^>]+\\ssvy-mention\\b[^>]*>\\$startRepeater.{{0}}<\\/span>(\\s|&nbsp;|<br>)*',
	END_REPEAT: '<span[^>]+\\ssvy-mention\\b[^>]*>\\$endRepeater.{{0}}<\\/span>(&nbsp;)?'
}

/**
 * @private
 * @type {plugins.http.HttpClient}
 * @properties={typeid:35,uuid:"6DFF7804-B4FF-4ECA-B4B1-82683FF14762",variableType:-4}
 */
var httpClient = plugins.http.createNewHttpClient();

/**
 * @private
 * @type {String}
 *
 * @properties={typeid:35,uuid:"FE971052-0410-49C1-BEE6-717C8D5C6680"}
 */
var apiKey = '';

/**
 * Default export service url, overridden by properties
 * @private
 * @type {String}
 *
 * @properties={typeid:35,uuid:"B52F7503-9FA9-4235-B9A9-BA0552E8F5DB"}
 */
var exportServiceURL = !application.isInDeveloper() && scopes.svyNet.isHostAccessible('localhost', 100, 4000) ? 'http://localhost:4000' : 'https://pdfexport.servoy-cloud.eu';

/**
 * Get a new instance of a document editor
 * @public
 * @param {RuntimeWebComponent<smartdocumenteditor-smartdocumenteditor_abs>|RuntimeWebComponent<smartdocumenteditor-smartdocumenteditor>} component The editor component
 * @return {DocumentEditor}
 *
 * @example<pre>
 * function onLoad(event) {
 *	// GET NE INSTANCE OF THE DOCUMENT EDITOR
 *	docEditor = scopes.svyDocEditor.getInstance(elements.smartDoc);
 *
 *	// POPULATE THE TAG FIELDS LIST
 *	var tagBuilder = docEditor.tagBuilder(datasources.db.example_data.orders.getDataSource());
 *	tagBuilder.addField('orderid');
 *	tagBuilder.addField('displayAddressHTML', 'Address');
 *	tagBuilder.addField('displayOrderDate', 'Order Date');
 *	tagBuilder.addField('displayShippedDate', 'Shipped Date');
 *	tagBuilder.addField('displayOrderTotal', 'Total');
 *	tagBuilder.addField('orders_to_customers.companyname', 'Customer.Company', false);
 *	tagBuilder.addField('orders_to_order_details.quantity', 'OrderDetails.Quantity');
 *	tagBuilder.addField('orders_to_order_details.unitprice', 'OrderDetails.Unit Price');
 *	tagBuilder.addField('orders_to_order_details.subtotal', 'OrderDetails.Subtotal');
 *	tagBuilder.addField('orders_to_order_details.order_details_to_products.productname', 'Product.Name', false);
 *
 *	// BUILD THE TAG LIST
 *	tagBuilder.build();
 * }
 * </pre>
 *
 * @properties={typeid:24,uuid:"47C90943-797B-4F20-9D1F-25FBF200808C"}
 */
function getInstance(component) {
	return new DocumentEditor(component);
}

/**
 * @private
 * @constructor
 * @param {RuntimeWebComponent<smartdocumenteditor-smartdocumenteditor_abs>|RuntimeWebComponent<smartdocumenteditor-smartdocumenteditor>} editor
 * @properties={typeid:24,uuid:"71EE688D-E2AD-4705-9247-F3FD5231FE74"}
 */
function DocumentEditor(editor) {

	/**
	 * Gets a tag builder object to set the lag libs for the editor component
	 *
	 * @public
	 * @param {JSDataSource|String} dataSource The data source for the tag libs
	 * @return {TagBuilder} The tag builder object
	 */
	this.tagBuilder = function(dataSource) {
		return new TagBuilder(dataSource, editor);
	};

	/**
	 * Merges tags with data and returns the content
	 *
	 * @public
	 * @param {JSRecord} record The record object from which to get data values
	 * @param {Boolean} [withInlineCSS] Optionally in-line the CSS so content is self-contained
	 * @param {String} [filterStylesheetName] Optionally filter by style sheet name
	 * @param {function(String, JSRecord):Boolean} [ifCallback] Optionally give callback function to parse if statements, return false will not hide the if block (Args: mentionRealValue).
	 * @param {function(String, String, String, String, JSRecord):*} [mentionCallback] Optionally give callback function to overwrite the record data (Args: dataProvider, relationName, relationIndex, value, mentionRealValue, mentionDisplayValue).
	 * @param {function(String, String, JSRecord):Boolean} [repeaterCallback] Optionally give callback function to overwrite the repeat, return false will not repeat (Args: relationName, mentionRealValue).
	 *
	 * @return {String} The merged content
	 */
	this.mergeTags = function(record, withInlineCSS, filterStylesheetName, ifCallback, mentionCallback, repeaterCallback) {
		return mergeTags(editor.getHTMLData(withInlineCSS, filterStylesheetName), record, ifCallback, mentionCallback, repeaterCallback);
	};

	/**
	 * Gets the content in the editor component
	 *
	 * @public
	 * @param {Boolean} [withInlineCSS] Optionally in-line the CSS so content is self-contained
	 * @param {String} [filterStylesheetName] Optionally filter by style sheet name
	 * @return {String}
	 */
	this.getContent = function(withInlineCSS, filterStylesheetName) {
		return editor.getHTMLData(withInlineCSS, filterStylesheetName);
	};

	/**
	 * Gets the default print css
	 *
	 * @public
	 * @return {String}
	 */
	this.getDefaultPrintCSS = function() {
		return printCSSStyle;
	};

	/**
	 * Gets the form component / element
	 *
	 * @public
	 * @return {RuntimeWebComponent<smartdocumenteditor-smartdocumenteditor_abs>|RuntimeWebComponent<smartdocumenteditor-smartdocumenteditor>}
	 */
	this.getElement = function() {
		return editor;
	};
}

/**
 *
 * Convert HTML from documentEditor into plain text.
 *
 * @public
 *
 * @param {String} html
 *
 * @return {String}
 *
 * @properties={typeid:24,uuid:"D3DBB34B-0760-4D72-A411-1864A34BC67C"}
 */
function HtmlToText(html) {
	var editorKit = new Packages.javax.swing.text.html.HTMLEditorKit();
	var doc = editorKit.createDefaultDocument();
	doc.putProperty("IgnoreCharsetDirective", true);
	try {
		var reader = new Packages.java.io.StringReader(html);
		editorKit.read(reader, doc, 0);
		reader.close();
		return doc.getText(0, doc.getLength());
	} catch (e) {
		return "";
	}
}

/**
 * @private
 * @constructor
 * @param {JSDataSource|String} dataSource
 * @param {RuntimeWebComponent<smartdocumenteditor-smartdocumenteditor_abs>|RuntimeWebComponent<smartdocumenteditor-smartdocumenteditor>} editor
 * @properties={typeid:24,uuid:"6E4E90A1-165A-43BD-887D-9A678DD85DD9"}
 */
function TagBuilder(dataSource, editor) {

	/**
	 * @type {String}
	 */
	var dsName = dataSource instanceof String ? dataSource : dataSource.getDataSource();

	/**
	 * @protected
	 * @type {Array<{displayValue:String,realValue:String}>}
	 */
	this.fieldTags = [];

	/**
	 * @protected
	 * @type {Array<String>}
	 */
	this.fieldRepeats = [];

	/**
	 * @protected
	 * @type {Array<{displayValue:String,realValue:String}>}
	 */
	this.ifTags = [];

	/**
	 * Add a field to the tag lib
	 *
	 * @public
	 * @param {String} dataProviderID The field, can be a column, calc, aggregate or related value
	 * @param {String} [displayTag] The display value for the tag. Default is derrived from the column or title property
	 * @param {Boolean} [repeats] true if the related field does repeat over multiple records. Default: true for all related fields.
	 * @param {String} [format] optional provided format used when merging the tags
	 * @param {Boolean} [forceAdd] optional when true it will skip the dataSource check, can be usefull when having overwrite fields
	 * @return {TagBuilder}
	 */
	this.addField = function(dataProviderID, displayTag, repeats, format, forceAdd) {
		var jsColumn = scopes.svyDataUtils.getDataProviderJSColumn(dsName, dataProviderID);
		if (!jsColumn) {
			if (!forceAdd) {
				var columnDs = dsName;
				if (dataProviderID.includes('.')) {
					var relationNames = scopes.svyDataUtils.getDataProviderRelationName(dataProviderID).split('.');
					for(var rel in relationNames) {
						if(!solutionModel.getRelation(relationNames[rel])) {
							application.output('Field cannot be added, because no relation with name: `' + relationNames[rel] + '` was found in the solution', LOGGINGLEVEL.ERROR);
							return this;
						}
							
					}
					columnDs = scopes.svyDataUtils.getRelationForeignDataSource(scopes.svyDataUtils.getDataProviderRelationName(dataProviderID));
				}
				
				var dsNode = solutionModel.getDataSourceNode(columnDs.toString());
				if (!dsNode.getCalculation(scopes.svyDataUtils.getUnrelatedDataProviderID(dataProviderID))) {
					application.output('Field cannot be added, because no column was found for: dataSource=' + dsName + ', dataProvider=' + dataProviderID, LOGGINGLEVEL.WARNING);
					return this;
				}
			}
		}

		if (!displayTag) {
			// dataprovider may be a calculation or an aggregation
			if (jsColumn) {
				displayTag = jsColumn.getTitle();
				if (dataProviderID.includes('.')) {
					displayTag = this.getJSTable(dataProviderID).getSQLName() + '.' + displayTag;
					if (displayTag.startsWith('TEMP_')) {
						displayTag = this.getJSTable(dataProviderID).getDataSource().split(':').pop() + '.' + displayTag;
					}
				}
			} else {
				displayTag = this.getJSTable(dataProviderID).getSQLName() + '.' + scopes.svyDataUtils.getUnrelatedDataProviderID(dataProviderID);
				if (displayTag.startsWith('TEMP_')) {
					displayTag = this.getJSTable(dataProviderID).getDataSource().split(':').pop() + '.' + scopes.svyDataUtils.getUnrelatedDataProviderID(dataProviderID);
				}
			}
		}

		if (dataProviderID.includes('.') && repeats !== false) {
			this.fieldRepeats.push(dataProviderID);
		}

		this.fieldTags.push({ displayValue: displayTag, realValue: dataProviderID, format: format });

		return this;
	};

	/**
	 * Function to clear the already added fields
	 * @public
	 */
	this.clearFields = function() {
		this.fieldTags = [];
		this.fieldRepeats = [];
	}

	/**
	 * Add a if to the tag lib
	 *
	 * @public
	 * @param {String} realValue The value send in the callback to validate the if statement
	 * @param {String} [displayValue] The display value for the tag.
	 *
	 * @return {TagBuilder}
	 */
	this.addIfTag = function(realValue, displayValue) {
		this.ifTags.push({ displayValue: DEFAULT_IF.IF_OPEN + '.' + (displayValue || realValue), realValue: realValue });
		return this;
	};

	/**
	 * Function to clear the already added ifTags
	 * @public
	 */
	this.clearIfTags = function() {
		this.ifTags = [];
	}

	/**
	 * @public
	 * @return {JSDataSet<displayValue:String, realValue:String>}
	 */
	this.getSystemTags = function() {
		var systemTags = { };
		for (var i in this.fieldRepeats) {
			var fieldTag = this.fieldRepeats[i];
			if (fieldTag.includes('.')) {
				var relationName = scopes.svyDataUtils.getDataProviderRelationName(fieldTag);
				var tableName = utils.stringReplace(utils.stringInitCap(this.getJSTable(fieldTag).getSQLName().split('_').join(' ')), ' ', '');
				if (this.getJSTable(fieldTag).getSQLName().startsWith('TEMP_')) {
					tableName = utils.stringReplace(utils.stringInitCap(this.getJSTable(fieldTag).getDataSource().split(':').pop().split('_').join(' ')), ' ', '');
				}
				var displayTagSuffix = '.' + tableName;
				var tagValueSuffix = '-' + relationName;
				systemTags[displayTagSuffix] = tagValueSuffix;
			}

		}
		/** @type {JSDataSet<displayValue:String, realValue:String>} */
		var dataset = databaseManager.createEmptyDataSet(0, ["displayValue", "realValue"]);
		if (Object.keys(systemTags).length > 0) {
			// dataset.addRow([DEFAULT_REPEATER.STOP, DEFAULT_REPEATER.STOP]);

			for (var display in systemTags) {
				dataset.addRow([ DEFAULT_REPEATER.START + display, DEFAULT_REPEATER.START + systemTags[display]]);
				dataset.addRow([ DEFAULT_REPEATER.STOP + display, DEFAULT_REPEATER.STOP + systemTags[display]]);
			}

		}
		return dataset;
	};

	/**
	 * Function to convert dataset to array (multi column)
	 *
	 * @param {JSDataSet<displayValue:String, realValue:String>} dataset
	 *
	 * @return {Array<{displayValue:String, realValue:String}>}
	 * @protected
	 */
	this.convertDataSetToArray = function(dataset) {
		/**@type {Array<{displayValue:String, realValue:String}>} */
		var valueArray = [];
		for (var i = 1; i <= dataset.getMaxRowIndex(); i++) {
			valueArray.push({ displayValue: dataset.getValue(i, 1), realValue: dataset.getValue(i, 2) });
		}
		return valueArray;
	};

	/**
	 * Fuction to get the JSTable also when dataprovider is a calculation
	 *
	 * @param {String} dataProviderID
	 *
	 * @return {JSTable}
	 * @protected
	 */
	this.getJSTable = function(dataProviderID) {
		var jsColumn = scopes.svyDataUtils.getDataProviderJSColumn(dsName, dataProviderID);
		if (!jsColumn) {
			var columnDs = dsName;
			if (dataProviderID.includes('.')) {
				columnDs = scopes.svyDataUtils.getRelationForeignDataSource(scopes.svyDataUtils.getDataProviderRelationName(dataProviderID));
			}
			return databaseManager.getTable(columnDs.toString());
		} else {
			return jsColumn.getTable();
		}
	};

	/**
	 * Applies the tag lib to the component (replacing existing tags)
	 * @public
	 */
	this.build = function() {
		var mentionFeeds = [{
				marker: TAGS.REPEAT,
				feedItems: this.convertDataSetToArray(this.getSystemTags())
			}, {
				marker: TAGS.TAG,
				feedItems: this.fieldTags
			}, {
				marker: TAGS.IF,
				feedItems: this.convertDataSetToArray(this.getIfTags())
			}];
		editor.setMentionFeeds(mentionFeeds);

	};

	/**
	 * @public
	 * @return {JSDataSet<displayValue:String, realValue:String>}
	 */
	this.getFields = function() {
		/** @type {JSDataSet<displayValue:String, realValue:String>} */
		var dataset = databaseManager.createEmptyDataSet(0, ["displayValue", "realValue"]);
		for (var i = 0; i < this.fieldTags.length; i++) {
			var fieldTag = this.fieldTags[i];
			dataset.addRow([fieldTag.displayValue, fieldTag.realValue]);
		}

		return dataset;
	};

	/**
	 * @public
	 * @return {JSDataSet<displayValue:String, realValue:String>}
	 */
	this.getIfTags = function() {
		/** @type {JSDataSet<displayValue:String, realValue:String>} */
		var dataset = databaseManager.createEmptyDataSet(0, ["displayValue", "realValue"]);
		for (var i = 0; i < this.ifTags.length; i++) {
			var ifTag = this.ifTags[i];
			dataset.addRow([ifTag.displayValue, ifTag.realValue]);
			dataset.addRow([ifTag.displayValue.replace(DEFAULT_IF.IF_OPEN,DEFAULT_IF.IF_CLOSE), ifTag.realValue.replace(DEFAULT_IF.IF_OPEN,DEFAULT_IF.IF_CLOSE)])
		}

		if (dataset.getMaxRowIndex() > 0) {
			//dataset.addRow([DEFAULT_IF.IF_CLOSE, DEFAULT_IF.IF_CLOSE]);
		}

		return dataset;
	};
}

/**
 * Merges tags with data and returns the merged content
 *
 * @public
 * @param {String} content The document's content
 * @param {JSRecord} record The data to merge
 * @param {function(String, JSRecord):Boolean} [ifCallback] Optionally give callback function to parse if statements, return false will not hide the if block (Args: mentionRealValue).
 * @param {function(String, String, String, String, JSRecord):*} [mentionCallback] Optionally give callback function to overwrite the record data (Args: mentionRealValue, mentionDisplayValue, dataProvider, relationName, record).
 * @param {function(String, String, JSRecord):Boolean} [repeaterCallback] Optionally give callback function to overwrite the repeat, return false will not repeat (Args: relationName, mentionRealValue).
 * @return {String} The merged content
 *
 * @example <pre>
 *	// MERGE TAGS WITH THE RECORD DATA
 *	var displayContent = scopes.svyDocEditor.mergeTags(content, record);
 *
 * 	// GET THE EXPORTER AND SET THE CONTENT
 *	var docExporter = scopes.svyDocEditor.getExporter();
 *	docExporter.setContent(displayContent);
 *
 *	try { // throws an exception if the API key isn't registered.
 *		var bytes = docExporter.exportToPDF();
 *		if (bytes) {
 *			var pdf = plugins.file.createFile('export.pdf');
 *			plugins.file.writeFile(pdf,bytes);
 *			plugins.file.openFile(pdf);
 *		} else {
 *			plugins.dialogs.showErrorDialog("Print Failed","Sorry cannot print the document.")
 *		}
 *	} catch (e) {
 *		plugins.dialogs.showWarningDialog("Print Failed", "API Key required for export");
 *	}
 * </pre>
 *
 * @properties={typeid:24,uuid:"B956081F-DA96-4E4B-AD6E-13F9264D5000"}
 */
function mergeTags(content, record, ifCallback, mentionCallback, repeaterCallback) {
	content = processRepeaters(content, record, repeaterCallback, ifCallback, mentionCallback);
	content = processRepeatersUnnamedEnd(content, record, repeaterCallback, ifCallback, mentionCallback);
	content = processIfBlocks(content, record, ifCallback)
	content = processIfBlocksSingleIfEnd(content, record, ifCallback);
	content = processMentions(content, record, null, mentionCallback);

	//Force fixing some non working HTML Chars:
	content = utils.stringReplace(content, '€', '&euro;');
	//Cleaning when having multiple repeaters in one row
	content = content.replace(/<p>\s*<\/p>/g, '');
	return content;
}

/**
 * @private
 *
 * @param {String} html
 * @param {JSRecord} record
 * @param {function(String,JSRecord):Boolean} [ifCallback]
 *
 * @return {String}
 * @properties={typeid:24,uuid:"93192AF2-73CB-49C6-A705-E14C8988FDCB"}
 */
function processIfBlocks(html, record, ifCallback) {
	if (!html) {
		return '';
	}
	
	var matches = html.match(REGEX.ALL_START_IF);
	if (!matches) {
		return html;
	}
	
	matches = matches.map(function (matchItem) {
		
		/** @type {String} */
		var match = matchItem.match(/data-mention=".*?"/gm)[0];
		// find the data mention value name
		var realValue = match.trim().replace('data-mention="', '').replace(/^@if./, '');
		
		// remove the last " char from the match
		return realValue.substr(0, realValue.length - 1);
	});
	
	matches.forEach(function (match) {
		
		var regIfBlock = new RegExp(REGEX_STRING.FULL_IF_BLOCK.replace(/\{\{0}}/g, match));
		regIfBlock.multiline = true;
		regIfBlock.global = true;
		
		// FIXME does not work well if the if tag
		html = html.replace(regIfBlock, function(matchItem) {
			var mention = new createParsedIf(matchItem);
			if (!mention.isValidIf()) {
				throw Error("Invalid tag item, tag item doesn't exist in valuelist for realValue: " + mention.parsedIfValue);
			}

			if (mention.parsedMention.tag == TAGS.IF) {

				//Added support for callback to overwrite / handle data parsing
				if (ifCallback && ifCallback(mention.parsedIfValue, record)) {
					//Clean Start & Close if tag
					
					var regIfStart = new RegExp(REGEX_STRING.START_IF.replace(/\{\{0}}/, match));
					regIfStart.multiline = true;
					regIfStart.global = true;
					
					var regIfEnd = new RegExp(REGEX_STRING.CLOSE_IF.replace(/\{\{0}}/, match));
					regIfEnd.multiline = true;
					regIfEnd.global = true;
					
					matchItem = matchItem.replace(regIfStart, '');
					matchItem = matchItem.replace(regIfEnd, '');
				} else {
					return '';
				}
			}
			
			// i need to search for the whole regex

			//If we have an new match inside the existing match we have to rerun it
			if (matchItem.match(regIfBlock)) {
				matchItem = processIfBlocks(matchItem, record, ifCallback);
			}

			return matchItem;
		}).replace(/color:var\(--ck-color-mention-text\);/g, ''); //Force replace the default ck-color-mention after parsing
		// now here i should replace the content
		
	});
	
	return html;
	// count all the tags first..
	// check all endif ( keep the old one as they are ? )
}

/**
 * This can manage only 1 single ifEnd block
 * @private
 *
 * @param {String} html
 * @param {JSRecord} record
 * @param {function(String,JSRecord):Boolean} [ifCallback]
 *
 * @return {String}
 * @properties={typeid:24,uuid:"2A4BB51D-041C-4988-BC74-5FAEC518E8CC"}
 */
function processIfBlocksSingleIfEnd(html, record, ifCallback) {
	if (!html) {
		return '';
	}

	return html.replace(REGEX.FULL_IF_BLOCK, function(matchItem) {
			var mention = new createParsedIf(matchItem);
			if (!mention.isValidIf()) {
				throw Error("Invalid tag item, tag item doesn't exist in valuelist for realValue: " + mention.parsedIfValue);
			}

			if (mention.parsedMention.tag == TAGS.IF) {

				//Added support for callback to overwrite / handle data parsing
				if (ifCallback && ifCallback(mention.parsedIfValue, record)) {
					//Clean Start & Close if tag
					matchItem = matchItem.replace(REGEX.START_IF, '');
					matchItem = matchItem.replace(REGEX.CLOSE_IF, '');
				} else {
					return '';
				}
			}
			
			// i need to search for the whole regex

			//If we have an new match inside the existing match we have to rerun it
			if (matchItem.match(REGEX.FULL_IF_BLOCK)) {
				matchItem = processIfBlocksSingleIfEnd(matchItem, record, ifCallback);
			}

			return matchItem;
		}).replace(/color:var\(--ck-color-mention-text\);/g, ''); //Force replace the default ck-color-mention after parsing
}

/**
 * @private
 *
 * @param {String} html
 * @param {JSRecord} record
 * @param {Number} [relationIndex]
 * @param {function(String, String, String, String, JSRecord):*} [mentionCallback]
 *
 * @return {String}
 * @properties={typeid:24,uuid:"782A1187-99C9-4BB4-995B-D7D282730EDA"}
 */
function processMentions(html, record, relationIndex, mentionCallback) {
	if (!html || !record) {
		return '';
	}

	return html.replace(REGEX.MENTION, function(matchItem) {
			var mention = new createParsedMention(matchItem);
			if (!mention.isValidTag()) {
				throw Error("Invalid tag item, tag item doesn't exist in valuelist for realValue: `" + mention.realValue + "`");
			}

			var data, dataProvider, relationName, relatedRecord;
			if (mention.tag == TAGS.TAG) {
				if (mention.realValue.includes('.')) {

					dataProvider = mention.getDataProvider();
					relationName = mention.getRelationBasedOnRecord(record);
					var path = relationName.split('.');
					// it assumes the first the relation is the one to be iterated, added extra check if from repeat it should be the full relation 
					var recordRelationName = (relationIndex != null) ? relationName : path.shift();
					var childRelationName = (relationIndex != null) ? null : path.join('.');

					if (utils.hasRecords(record, recordRelationName) && dataProvider) {
						// in case of nested relations. Iterate over the first relation
						relatedRecord = record[recordRelationName].getRecord( (relationIndex || 1));
						// data for nested relations
						if (relatedRecord && childRelationName && utils.hasRecords(relatedRecord, childRelationName)) {
							data = relatedRecord[childRelationName][dataProvider];
						} else if (relatedRecord && !childRelationName) {
							data = relatedRecord[dataProvider];
						}
					}
					//Skip for now it is a relation dataprovider;
				} else {
					dataProvider = mention.realValue;
					data = record[dataProvider];
				}

				//Added support for callback to overwrite / handle data parsing
				if (mentionCallback) {
					//push record not relationIndex
					data = mentionCallback(mention.realValue, mention.display, dataProvider, relationName||null, relatedRecord||record);
				}

				if (data instanceof Date) {
					return utils.dateFormat(data, mention.format || 'dd-MM-yyyy HH:mm');
				} else if (mention.format) {
					return utils.numberFormat(data, mention.format);
				}
				return data == null ? '' : data;
			}
			return matchItem;
		}).replace(/color:var\(--ck-color-mention-text\);/g, ''); //Force replace the default ck-color-mention after parsing
}

/**
 * @private
 * @param {String} html
 * @param {JSRecord} record
 * @param {function(String, String, JSRecord):Boolean} [repeaterCallback]
 * @param {function(String,JSRecord):Boolean} [ifCallback]
 * @param {function(String, String, String, String, JSRecord):*} [mentionCallback]
 *
 * @return {String}
 * @properties={typeid:24,uuid:"0B148351-1FC0-4FC3-96AA-2AC53E485CAA"}
 */
function processRepeaters(html, record, repeaterCallback, ifCallback, mentionCallback) {
	var repeatItem;
	if (!html || !record) {
		return '';
	}
	
	var matches = html.match(REGEX.ALL_START_REPEAT);
	if (!matches) {
		return html;
	}
	
	matches = matches.map(function (matchItem) {
		
		/** @type {String} */
		var match = matchItem.match(/data-mention=".*?"/gm)[0];
		// find the data mention value name
		var realValue = match.trim().replace('data-mention="', '').replace(/^\$startRepeater./, '');
		
		// remove the last " char from the match
		return realValue.substr(0, realValue.length - 1);
	});
	
	// MY MATCHES
	application.output(matches);
	application.output('*****************************************')

	var returnHTMLValue = html;
	
	matches.forEach(function (match) {
		
		var regIfBlock = new RegExp(REGEX_STRING.FULL_REPEAT_BLOCK.replace(/\{\{0}}/g, match));
		regIfBlock.multiline = true;
		regIfBlock.global = true;
	
		//Try to keep track if block is valid
		var hasValidMatch = false;
		/** @param {String} matchItem */
		function repeatProcessor(matchItem) {
			repeatItem = new createParsedRepeat(matchItem, record);
			if (!repeatItem.isValidRepeat()) {
				throw Error("Invalid repeat item, repeat item doesn't exist in valuelist for relation: " + repeatItem.relationName);
			}
			
			var regIfStart = new RegExp(REGEX_STRING.START_REPEAT.replace(/\{\{0}}/, match));
			regIfStart.multiline = true;
			regIfStart.global = true;
			
			var regIfEnd = new RegExp(REGEX_STRING.END_REPEAT.replace(/\{\{0}}/, match));
			regIfEnd.multiline = true;
			regIfEnd.global = true;
			
			var regRepeatEndLastLine = new RegExp(REGEX_STRING.END_REPEAT.replace(/\{\{0}}/, match) + '$');
			regRepeatEndLastLine.multiline = true;
			regRepeatEndLastLine.global = true;
			
			//Temp clean first & last repeater to see if block is still valid
			var tempCleaner = matchItem.replace(regIfStart, '');
			tempCleaner = tempCleaner.replace(regRepeatEndLastLine, '');
			
			//Undo replace when it isn't a correct repeat block
			if (tempCleaner.match(regIfEnd) && !tempCleaner.match(regIfBlock)) {
				return matchItem;
			} else {
				hasValidMatch = true
			}
			//If block is still valid.. we write it back and start using that one
			matchItem = tempCleaner;
	
			//Build repeated items
			if (repeatItem.numberOfRepeats == 0) {
				return '';
			} else {
				var newValue = '';
				var toRepeat = matchItem;
				if (repeatItem.isTableStartEndRepeat()) {
					toRepeat = matchItem.match(REGEX.FULL_TABLE_ROW)[0].replace(REGEX.FULL_TABLE_HEADER, '');
					newValue = matchItem.match(REGEX.FULL_TABLE_HEADER) ? matchItem.match(REGEX.FULL_TABLE_HEADER)[0] : '';
				}
				if (repeaterCallback && !repeaterCallback(repeatItem.parsedMention.realValue, repeatItem.relationName, record)) {
					toRepeat = '';
				}
	
				//Force reapply the sorting, when not done only the first time the sort is correct.
				if (record[repeatItem.getRelationBasedOnRecord(record)].getCurrentSort()) {
					record[repeatItem.getRelationBasedOnRecord(record)].sort(record[repeatItem.getRelationBasedOnRecord(record)].getCurrentSort());
				}
	
				for (var i = 1; i <= repeatItem.numberOfRepeats; i++) {
					var processedRepeat = toRepeat;
					
					// here i need to search for child repeaters
					
					// TODO check for the end
					if (matchItem.match(REGEX.ALL_START_REPEAT)) {
						processedRepeat = processRepeaters(toRepeat, record[repeatItem.getRelationBasedOnRecord(record)].getRecord(i), repeaterCallback, ifCallback, mentionCallback);
					}
	
					// check for legacy @endIf
					if (REGEX.FULL_IF_BLOCK.test(processedRepeat)) {
						newValue += processIfBlocksSingleIfEnd(processedRepeat, record[repeatItem.getRelationBasedOnRecord(record)].getRecord(i), ifCallback);
					} else {
						newValue += processIfBlocks(processedRepeat, record[repeatItem.getRelationBasedOnRecord(record)].getRecord(i), ifCallback);
					}
					newValue = processMentions(newValue, record, i, mentionCallback);
				}
	
				//Clean latest enter
				return (repeatItem.isTableStartEndRepeat() ? matchItem.replace(REGEX.FULL_TABLE_ROW, newValue) : newValue).trim().replace(REGEX.BR_END, '');
			}
		}
		
		// replace all occurrances
		var htmlToReplace = html;
		
		// FIXME i need to change a lot here to manage repeat of nested content.
		// in each match i need to search if there are nested items.
		while (htmlToReplace.match(regIfBlock)) {

			var innerReturnHTMLValue = htmlToReplace.replace(regIfBlock, repeatProcessor);
			if (!hasValidMatch) {
				innerReturnHTMLValue = htmlToReplace.replace(REGEX.FULL_REPEAT_BLOCK_FIRST_MATCH, repeatProcessor);
			}

			htmlToReplace = innerReturnHTMLValue;
		} 

		//return returnHTMLValue
		returnHTMLValue = innerReturnHTMLValue;
	});
	
	return returnHTMLValue
}


/**
 * @private
 * @param {String} html
 * @param {JSRecord} record
 * @param {function(String, String, JSRecord):Boolean} [repeaterCallback]
 * @param {function(String,JSRecord):Boolean} [ifCallback]
 * @param {function(String, String, String, String, JSRecord):*} [mentionCallback]
 *
 * @return {String}
 * @properties={typeid:24,uuid:"4D3C4CE2-8B01-4FDD-8C56-2541C7427305"}
 */
function processRepeatersUnnamedEnd(html, record, repeaterCallback, ifCallback, mentionCallback) {
	var repeatItem;
	if (!html || !record) {
		return '';
	}

	//Try to keep track if block is valid
	var hasValidMatch = false;
	/** @param {String} matchItem */
	function repeatProcessor(matchItem) {
		repeatItem = new createParsedRepeat(matchItem, record);
		if (!repeatItem.isValidRepeat()) {
			throw Error("Invalid repeat item, repeat item doesn't exist in valuelist for relation: " + repeatItem.relationName);
		}
		//Temp clean first & last repeater to see if block is still valid
		var tempCleaner = matchItem.replace(REGEX.START_REPEAT, '');
		tempCleaner = tempCleaner.replace(REGEX.END_REPEAT$, '');
		//Undo replace when it isn't a correct repeat block
		if (tempCleaner.match(REGEX.END_REPEAT) && !tempCleaner.match(REGEX.FULL_REPEAT_BLOCK)) {
			return matchItem;
		} else {
			hasValidMatch = true
		}
		//If block is still valid.. we write it back and start using that one
		matchItem = tempCleaner;

		//Build repeated items
		if (repeatItem.numberOfRepeats == 0) {
			return '';
		} else {
			var newValue = '';
			var toRepeat = matchItem;
			if (repeatItem.isTableStartEndRepeat()) {
				toRepeat = matchItem.match(REGEX.FULL_TABLE_ROW)[0].replace(REGEX.FULL_TABLE_HEADER, '');
				newValue = matchItem.match(REGEX.FULL_TABLE_HEADER) ? matchItem.match(REGEX.FULL_TABLE_HEADER)[0] : '';
			}
			if (repeaterCallback && !repeaterCallback(repeatItem.parsedMention.realValue, repeatItem.relationName, record)) {
				toRepeat = '';
			}

			//Force reapply the sorting, when not done only the first time the sort is correct.
			if (record[repeatItem.getRelationBasedOnRecord(record)].getCurrentSort()) {
				record[repeatItem.getRelationBasedOnRecord(record)].sort(record[repeatItem.getRelationBasedOnRecord(record)].getCurrentSort());
			}

			for (var i = 1; i <= repeatItem.numberOfRepeats; i++) {
				var processedRepeat = toRepeat;
				if (matchItem.match(REGEX.FULL_REPEAT_BLOCK)) {
					processedRepeat = processRepeatersUnnamedEnd(toRepeat, record[repeatItem.getRelationBasedOnRecord(record)].getRecord(i), repeaterCallback, ifCallback, mentionCallback);
				}
				// check for legacy @endIf
				if (REGEX.FULL_IF_BLOCK.test(processedRepeat)) {
					newValue += processIfBlocksSingleIfEnd(processedRepeat, record[repeatItem.getRelationBasedOnRecord(record)].getRecord(i), ifCallback);
				} else {
					newValue += processIfBlocks(processedRepeat, record[repeatItem.getRelationBasedOnRecord(record)].getRecord(i), ifCallback);
				}
				newValue = processMentions(newValue, record, i, mentionCallback);
			}

			//Clean latest enter
			return (repeatItem.isTableStartEndRepeat() ? matchItem.replace(REGEX.FULL_TABLE_ROW, newValue) : newValue).trim().replace(REGEX.BR_END, '');
		}
	}
	var returnHTMLValue = html.replace(REGEX.FULL_REPEAT_BLOCK, repeatProcessor);
	if (!hasValidMatch) {
		returnHTMLValue = html.replace(REGEX.FULL_REPEAT_BLOCK_FIRST_MATCH, repeatProcessor);
	}
	return returnHTMLValue
}

/**
 * @private
 * @constructor
 *
 * @param {String} html
 * @param {JSRecord} record
 *
 * @properties={typeid:24,uuid:"AA1FC697-2CDB-4506-9890-834DDA8A80DF"}
 */
function createParsedRepeat(html, record) {
	/** @type {String} */
	this.relationName = '';

	/** @type {Number} */
	this.numberOfRepeats = 0;

	/** @type {Boolean} */
	this.hasTableStartRepeat = !!html.match(REGEX.START_REPEAT_TABLE);

	/** @type {Boolean} */
	this.hasTableEndRepeat = !!html.match(REGEX.END_REPEAT_TABLE);

	/** @type {createParsedMention} */
	this.parsedMention = new createParsedMention(html.match(REGEX.START_REPEAT)[0]);

	/**
	 * @return {Boolean}
	 */
	this.isTableStartEndRepeat = function() {
		return (this.hasTableStartRepeat && this.hasTableEndRepeat);
	};

	/**
	 * @return {Boolean}
	 */
	this.isValidRepeat = function() {
		return !!this.relationName;
	};

	/**
	 * @param {JSRecord} currentRecord
	 * @return {String}
	 */
	this.getRelationBasedOnRecord = function(currentRecord) {
		var hasMatch = false;
		if (this.relationName.includes('.')) {
			return this.relationName.split('.').filter(function(relation) {
				if (!hasMatch) {
					hasMatch = (scopes.svyDataUtils.getRelationPrimaryDataSource(relation) == currentRecord.getDataSource());
				}
				return hasMatch;
			}).join('.');
		} else {
			return this.relationName;
		}
	};

	//Setup calculated properties based on input
	if (this.parsedMention && this.parsedMention.tag == TAGS.REPEAT) {
		this.relationName = this.parsedMention.realValue;
		if (utils.hasRecords(record, this.getRelationBasedOnRecord(record))) {
			this.numberOfRepeats = databaseManager.getFoundSetCount(record[this.getRelationBasedOnRecord(record)]);
		}
	}
}

/**
 * @private
 * @constructor
 *
 * @param {String} html
 *
 * @properties={typeid:24,uuid:"797B971B-7967-48EA-9DDA-13A17646FDF9"}
 */
function createParsedIf(html) {
	/** @type {createParsedMention} */
	this.parsedMention = new createParsedMention(html.match(REGEX.START_IF)[0]);

	/** @type {String}*/
	this.parsedIfValue = '';

	/**
	 * @return {Boolean}
	 */
	this.isValidIf = function() {
		return true;
	};

	//Setup calculated properties based on input
	if (this.parsedMention && this.parsedMention.tag == TAGS.IF) {
		this.parsedIfValue = this.parsedMention.realValue;
	}
}

/**
 * @private
 * @constructor
 *
 * @param {String} mention
 *
 * @properties={typeid:24,uuid:"3B7C71E4-2B7F-493F-B622-08F53962BEE1"}
 */
function createParsedMention(mention) {
	/** @type {String} */
	this.display = '';

	/** @type {String} */
	this.realValue = '';

	/** @type {String} */
	this.tag = '';

	/** @type {String} */
	this.format = null;

	/**
	 * @return {Boolean}
	 */
	this.isValidTag = function() {
		return !!this.realValue;
	};

	/**
	 * @param {JSRecord} record
	 * @return {String}
	 */
	this.getRelationBasedOnRecord = function(record) {
		var hasMatch = false;
		if (this.realValue.includes('.')) {
			return scopes.svyDataUtils.getDataProviderRelationName(this.realValue).split('.').filter(function(relation) {
				if (!hasMatch) {
					hasMatch = (scopes.svyDataUtils.getRelationPrimaryDataSource(relation) == record.getDataSource());
				}
				return hasMatch;
			}).join('.');
		} else {
			return this.realValue;
		}
	};

	/**
	 * @return {String}
	 */
	this.getDataProvider = function() {
		return scopes.svyDataUtils.getUnrelatedDataProviderID(this.realValue);
	};

	var value = '';
	var match = mention.match(/data-.*?=".*?"/gm);
	var self = this;
	match.forEach(/**@param {String} matchItem */ function(matchItem) {
		if (matchItem.startsWith('data-mention=')) {
			value = matchItem.trim().replace('data-mention="', '').replace(/"$/, '');
			self.tag = value.substr(0, 1);
			self.display = value.substr(1);
		} else if (matchItem.startsWith('data-real-value=')) {
			value = matchItem.trim().replace('data-real-value="', '').replace(/"$/, '');
			self.realValue = value.split(DEFAULT_REPEATER.START + '-').pop();
		} else if (matchItem.startsWith('data-format=')) {
			value = matchItem.trim().replace('data-format="', '').replace(/"$/, '');
			self.format = value;
		}
	});
}

/**
 * Get's an exporter which can generate PDF exports
 *
 * @public
 * @return {Exporter}
 * @example <pre>
 * 	// GET THE EXPORTER AND SET THE CONTENT
 *	var docExporter = scopes.svyDocEditor.getExporter();
 *	docExporter.setContent(displayContent);
 *
 *	try { // throws an exception if the API key isn't registered.
 *		var bytes = docExporter.exportToPDF();
 *		if (bytes) {
 *			var pdf = plugins.file.createFile('export.pdf');
 *			plugins.file.writeFile(pdf,bytes);
 *			plugins.file.openFile(pdf);
 *		} else {
 *			plugins.dialogs.showErrorDialog("Print Failed","Sorry cannot print the document.")
 *		}
 *	} catch (e) {
 *		plugins.dialogs.showWarningDialog("Print Failed", "API Key required for export");
 *	}
 * </pre>
 *
 * @properties={typeid:24,uuid:"E8B1F610-7727-4661-8B56-1F38F0583A81"}
 */
function getExporter() {
	return new Exporter();
}

/**
 * @private
 * @constructor
 * @properties={typeid:24,uuid:"F3899FE4-3E92-4806-87D8-F1FE7166E5E8"}
 */
function Exporter() {

	/** @protected **/
	this.content = '';

	/** @protected **/
	this.css = printCSSStyle;

	/** @protected **/
	this.headTags = [];

	/** @protected **/
	this.imageURL = application.getServerURL();

	/** @protected **/
	this.margin = { "bottom": 20, "left": 12, "right": 12, "top": 20 };

	/** @protected **/
	this.pageSize = { "size": 'A4', "width": 21, "height": 29.7 };

	/** @protected **/
	this.orientation = 'Portrait';

	/** @protected **/
	this.smartShrinking = true;
	
	/** @protected **/
	this.imageQuality = 100;
	
	/** @protected **/
	this.imageType = 'png';
	
	/** @protected **/
	this.imageScaleFactor = 1;
	
	/** @protected **/
	this.footerHTML = '';
	
	/** @protected **/
	this.headerHTML = '';
	
	/** @protected **/
	this.headerHeight = 0
	
	/** @protected **/
	this.footerHeight = 0
	
	/** @protected **/
	this.pageOffset = 0;

	/**
	 * Set/Override the smartShrinking property for generating the PDF
	 *
	 * Enable the intelligent shrinking strategy used by WebKit that makes the pixel/dpi ratio non-constant
	 *
	 * @public
	 * @param {Boolean} enableSmartShrinking
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.setSmartShrinking = function(enableSmartShrinking) {
		this.smartShrinking = !!enableSmartShrinking;
		return this;
	};

	/**
	 * Set/Override the css in the exporter
	 *
	 * @public
	 * @param {String} css The CSS to set
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.setCSS = function(css) {
		this.css = css;
		return this;
	};

	/**
	 * Extend the css of the exporter
	 *
	 * @public
	 * @param {String} css The CSS to set
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.addCss = function(css) {
		this.css += ('\n\n' + css);
		return this;
	};

	/**
	 * Sets the content to be exported
	 * @public
	 * @param {String} content
	 * @return {Exporter} This exporter object for call chaining
	 * @see DocumentEditor.getContent
	 */
	this.setContent = function(content) {
		if (!content.includes("<body>") && !content.includes("<html>")) {
			this.content = '<html><body><div class="ck-content" dir="ltr">' + content + '</div></body></html>';
		} else {
			this.content = content;
		}
		return this;
	};
	
	/**
	 * Sets the pageHeader HTML to be exported this will be printed on every page
	 * @public
	 * @param {String} header
 	 * @param {Number} [height]
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.setPageHeaderHtml = function(header, height) {
		if (!header.includes("<body>") && !header.includes("<html>")) {
			this.headerHTML = '<html><body><div class="ck-content" dir="ltr">' + header + '</div></body></html>';
		} else {
			this.headerHTML = header;
		}
		
		if(height) {
			this.headerHeight = height;
		}
		return this;
	};
	
	/**
	 * Sets the page offset to use for the params used in pageHeader/pageFooter HTML to be exported this will be printed on every page
	 * @public
	 * @param {Number} number
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.setPageOffset = function(number) {
		this.pageOffset = number;
		return this;
	}
	
	/**
	 * Sets the pageFooter HTML to be exported this will be printed on every page
	 * @public
	 * @param {String} footer
	 * @param {Number} [height]
	 * @return {Exporter} This exporter object for call chaining
	 * @see DocumentEditor.getContent
	 */
	this.setPageFooterHtml = function(footer, height) {
		if (!footer.includes("<body>") && !footer.includes("<html>")) {
			this.footerHTML = '<html><body><div class="ck-content" dir="ltr">' + footer + '</div></body></html>';
		} else {
			this.footerHTML = footer;
		}
		
		if(height) {
			this.footerHeight = height;
		}
		return this;
	};

	/**
	 * Adds additional head tags to the exported content
	 *
	 * @public
	 * @param {String} headTag The head tag to be added
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.addHeadTag = function(headTag) {
		this.headTags.push(headTag);
		return this;
	};

	/**
	 * Sets the image URL
	 * @public 
	 * @param {String} imageURL The Image URL
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.setImageURL = function(imageURL) {
		this.imageURL = imageURL;
		return this;
	};

	/**
	 * Sets the page margins only used when exporting to PDF
	 * 
	 * @public
	 * @param {Number} top
	 * @param {Number} right
	 * @param {Number} bottom
	 * @param {Number} left
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.setMargin = function(top, right, bottom, left) {
		this.margin = { top: top, right: right, bottom: bottom, left: left };
		return this;
	};

	/**
	 * Sets the page size only used when exporting to PDF
	 * @public
	 * @param {String} pageSize Page size, must be one of enum PAGE_SIZE
	 * @param {Number} pageWidth Page width in CM
	 * @param {Number} pageHeight Page height in CM
	 * @return {Exporter} This exporter object for call chaining
	 * @see PAGE_SIZE
	 */
	this.setPageSize = function(pageSize, pageHeight, pageWidth) {
		this.pageSize.size = pageSize;
		this.pageSize.height = pageHeight;
		this.pageSize.width = pageWidth;
		return this;
	};

	/**
	 * Sets the page width size
	 * @public
	 * @param {Number} pageWidth Page width in CM
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.setPageWidth = function(pageWidth) {
		this.pageSize.width = pageWidth
		return this
	}
	
	/**
	 * Sets the page height size
	 * @public
	 * @param {Number} pageHeight Page width in CM
	 * @return {Exporter} This exporter object for call chaining
	 */
	this.setPageHeight = function(pageHeight) {
		this.pageSize.height = pageHeight
		return this
	}
	
	/**
	 * Sets the page orientation only used when exporting to PDF
	 *
	 * @public
	 * @param {String} orientation The page orientation, must be one of enum ORIENTATION
	 * @return {Exporter} This exporter object for call chaining
	 * @see ORIENTATION
	 */
	this.setOrientation = function(orientation) {
		this.orientation = orientation;
		return this;
	};

	/**
	 * Sets the image quality only used when exporting to IMAGE
	 *
	 * @public
	 * @param {Number} quality Sets the image quality
	 * @return {Exporter} This exporter object for call chaining
	 * @see ORIENTATION
	 */
	this.setImageQuality = function(quality) {
		this.imageQuality = quality
		return this;
	}
	
	/**
	 * Sets the image type only used when exporting to IMAGE
	 *
	 * @public
	 * @param {String} type Sets the image type, can be png, webp or jpeg
	 * @return {Exporter} This exporter object for call chaining
	 * @see ORIENTATION
	 */
	this.setImageType = function(type) {
		this.imageType = type;
		return this;
	}
	
	/**
	 * Sets the image scaleFactor only used when exporting to IMAGE
	 *
	 * @public
	 * @param {Number} scaleFactor Sets the image scaleFactor
	 * @return {Exporter} This exporter object for call chaining
	 * @see ORIENTATION
	 */
	this.setImageScaleFactor = function(scaleFactor) {
		this.imageScaleFactor = scaleFactor;
		return this;
	}
	
	/**
	 * Exports the content to PDF. An API key must already be registered or an error is thrown.
	 *
	 * @public
	 * @return {Array<byte>} The PDF file bytes
	 * @see registerAPIKey
	 * @throws {Error} if no API key is registered
	 */
	this.exportToPDF = function() {
		if (!apiKey) {
			throw Error('No API found');
		}
		var post = httpClient.createPostRequest(exportServiceURL + '/generatePDF');
		post.setBodyContent(JSON.stringify(this.serialize()));
		var result = post.executeRequest();
		if (result.getStatusCode() == 200) {
			return result.getMediaData();
		} else {
			application.output('Connection Error: ' + result.getStatusCode() + ' with error: ' + result.getResponseBody(), LOGGINGLEVEL.ERROR);
			return null;
		}
	};

	/**
	 * Exports Async the content to PDF. An API key must already be registerd or an error is thrown
	 *
	 * @public
	 * @param {function(Array<byte>)} success Callback function called when async was success
	 * @param {function(Number)} [error] Callback function called when async got an connection error
	 * @param {Array<*>} [extraArguments] Callback function extra arguments, first argument will be pdfByteArray
	 *
	 * @see registerAPIKey
	 */
	this.exportToPDFAsync = function(success, error, extraArguments) {
		if (!apiKey) {
			throw Error('No API found');
		}
		var post = httpClient.createPostRequest(exportServiceURL + '/generatePDF');
		post.setBodyContent(JSON.stringify(this.serialize()));
		post.executeAsyncRequest(asyncSuccessCallback, asyncErrorCallback, [scopes.svySystem.convertServoyMethodToQualifiedName(success), scopes.svySystem.convertServoyMethodToQualifiedName(error)].concat(extraArguments || []));
		return null;
	};
	
	/**
	 * Exports the content to Docx. An API key must already be registered or an error is thrown.
	 *
	 * @public
	 * @return {Array<byte>} The PDF file bytes
	 * @see registerAPIKey
	 * @throws {Error} if no API key is registered
	 */
	this.exportToDocx = function() {
		if (!apiKey) {
			throw Error('No API found');
		}
		var post = httpClient.createPostRequest(exportServiceURL + '/generateDocx');
		post.setBodyContent(JSON.stringify(this.serialize()));
		var result = post.executeRequest();
		if (result.getStatusCode() == 200) {
			return result.getMediaData();
		} else {
			application.output('Connection Error: ' + result.getStatusCode() + ' with error: ' + result.getResponseBody(), LOGGINGLEVEL.ERROR);
			return null;
		}
	};

	/**
	 * Exports Async the content to Docx. An API key must already be registerd or an error is thrown
	 *
	 * @public
	 * @param {function(Array<byte>)} success Callback function called when async was success
	 * @param {function(Number)} [error] Callback function called when async got an connection error
	 * @param {Array<*>} [extraArguments] Callback function extra arguments, first argument will be pdfByteArray
	 *
	 * @see registerAPIKey
	 */
	this.exportToDocxAsync = function(success, error, extraArguments) {
		if (!apiKey) {
			throw Error('No API found');
		}
		var post = httpClient.createPostRequest(exportServiceURL + '/generateDocx');
		post.setBodyContent(JSON.stringify(this.serialize()));
		post.executeAsyncRequest(asyncSuccessCallback, asyncErrorCallback, [scopes.svySystem.convertServoyMethodToQualifiedName(success), scopes.svySystem.convertServoyMethodToQualifiedName(error)].concat(extraArguments || []));
		return null;
	};

	/**
	 * Exports the content to PNG/JPEG File. An API key must already be registered or an error is thrown.
	 *
	 * @public
	 * @return {Array<byte>} The PDF file bytes
	 * @see registerAPIKey
	 * @throws {Error} if no API key is registered
	 */
	this.exportToImage  = function() {
		if (!apiKey) {
			throw Error('No API found');
		}
		var post = httpClient.createPostRequest(exportServiceURL + '/generateImage');
		post.setBodyContent(JSON.stringify(this.serialize()));
		var result = post.executeRequest();
		if (result.getStatusCode() == 200) {
			return result.getMediaData();
		} else {
			application.output('Connection Error: ' + result.getStatusCode() + ' with error: ' + result.getResponseBody(), LOGGINGLEVEL.ERROR);
			return null;
		}
	};
	
	/**
	 * Exports Async content to PNG/JPEG File. An API key must already be registered or an error is thrown.
	 *
	 * @public
	 * @param {function(Array<byte>)} success Callback function called when async was success
	 * @param {function(Number)} [error] Callback function called when async got an connection error
	 * @param {Array<*>} [extraArguments] Callback function extra arguments, first argument will be pdfByteArray
	 *
	 * @see registerAPIKey
	 */
	this.exportToImageAsync = function(success, error, extraArguments) {
		if (!apiKey) {
			throw Error('No API found');
		}
		var post = httpClient.createPostRequest(exportServiceURL + '/generateImage');
		post.setBodyContent(JSON.stringify(this.serialize()));
		post.executeAsyncRequest(asyncSuccessCallback, asyncErrorCallback, [scopes.svySystem.convertServoyMethodToQualifiedName(success), scopes.svySystem.convertServoyMethodToQualifiedName(error)].concat(extraArguments || []));
		return null;
	};
	
	/**
	 * @protected
	 * @return {Object}
	 */
	this.serialize = function() {
		return {
			"key": apiKey,
			"html": this.content,
			"css": this.css,
			"additionalHead": this.headTags,
			"imageURL": this.imageURL,
			"margin": this.margin,
			"paperSize": this.pageSize,
			"orientation": this.orientation,
			"imageScaleFactor": this.imageScaleFactor,
			"imageType": this.imageType,
			"imageQuality": this.imageQuality,
			"headerHeight": this.headerHeight,
			"pageHeaderHTML": this.headerHTML,
			"footerHeight": this.footerHeight,
			"pageFooterHTML": this.footerHTML,
			"pageOffset": this.pageOffset
		};
	};
}

/**
 * @private
 *
 * Function wrapper for async pdf request
 *
 * @param {plugins.http.Response} response
 * @param {String} [cbFunctionSuccess]
 * @param {String} [cbFunctionError]
 *
 * @properties={typeid:24,uuid:"0E06619F-AB39-494E-BC95-B712253D2F9B"}
 */
function asyncSuccessCallback(response, cbFunctionSuccess, cbFunctionError) {
	var args = [];
	if (arguments.length > 3) {
		for (var i = 3; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
	}
	if (response.getStatusCode() == 200) {
		args.unshift(response.getMediaData());
		scopes.svySystem.callMethod(cbFunctionSuccess, args);
	} else {
		application.output('Connection Error: ' + response.getStatusCode() + ' with error: ' + response.getResponseBody(), LOGGINGLEVEL.ERROR);
		scopes.svySystem.callMethod(cbFunctionError, [response.getStatusCode(), response.getResponseBody()].concat(args));
	}
}

/**
 * @private
 *
 * Function wrapper for async pdf request
 *
 * @param {plugins.http.Response} response
 * @param {String} [cbFunctionSuccess]
 * @param {String} [cbFunctionError]
 *
 * @properties={typeid:24,uuid:"891A10A4-2E26-4F7E-8106-8C9CC32621EA"}
 */
function asyncErrorCallback(response, cbFunctionSuccess, cbFunctionError) {
	var args = [];
	if (arguments.length > 3) {
		for (var i = 3; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
	}
	if (response.getStatusCode() != 200) {
		application.output('Connection Error: ' + response.getStatusCode() + ' with error: ' + response.getResponseBody(), LOGGINGLEVEL.ERROR);
		scopes.svySystem.callMethod(cbFunctionError, [response.getStatusCode(), response.getResponseBody()].concat(args));
	}
}

/**
 * Register the API key required for PDF export.
 * This method is best used for testing purposes only.
 * For deployment purposes, the key can be loaded from configuration using property "user.svyDocumentEditorAPIKey"
 *
 * @param {String} key
 * @public
 *
 * @properties={typeid:24,uuid:"0C251095-663C-4F8A-9F85-57983C04989F"}
 */
function registerAPIKey(key) {
	apiKey = key;
	application.setUserProperty('svyDocumentEditorAPIKey', key);
	if (application.isInDeveloper()) {
		application.output('Key is set, but when in developer, user properties are not persisted until the IDE is closed', LOGGINGLEVEL.INFO);
	} else {
		application.output('svyDocumentEditorAPIKey set at runtime', LOGGINGLEVEL.INFO);
	}
}

/**
 * Scope initialization. DO NOT put any code below this declaration
 * ----------------------------------------------------------------
 * @private
 * @SuppressWarnings(unused)
 * @properties={typeid:35,uuid:"4C1849DF-4498-4307-86AB-EA247E1C0384",variableType:-4}
 */
var init = function() {
	var key = application.getUserProperty('svyDocumentEditorAPIKey');
	if (key) {
		application.output('svyDocumentEditorAPIKey loaded from configuration', LOGGINGLEVEL.INFO);
		apiKey = key;
	}
	var url = application.getUserProperty('svyDocumentExportServiceURL');
	if (url) {
		exportServiceURL = url;
		application.output('svyDocumentExportServiceURL loaded from configuration', LOGGINGLEVEL.INFO);
	}
}();